<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Job Card Creator</title>
    <!-- UTIF.js for TIFF support -->
    <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.js"></script>
    
    <style>
        :root {
            --bg-color: #f0f2f5;
            --paper-color: #ffffff;
            --line-color: #94a3b8; /* Darker for better print visibility */
            --primary-color: #2563eb;
            --danger-color: #ef4444;
            --handle-color: #3b82f6;
        }

        * {
            box-sizing: border-box;
            user-select: none; /* Prevent text selection while dragging */
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* --- UI Controls --- */
        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
            align-items: center;
            flex-wrap: wrap;
            justify-content: flex-end;
            max-width: 90vw;
        }

        .input-group {
            display: flex;
            align-items: center;
            background: white;
            padding: 8px 16px;
            border-radius: 50px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            gap: 10px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .input-group input {
            width: 50px;
            padding: 4px;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
        }

        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px -1px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.print-btn {
            background-color: #059669;
        }
        
        .btn.auto-btn {
            background-color: #7c3aed;
        }

        #fileInput {
            display: none;
        }

        .instructions {
            margin-bottom: 20px;
            color: #64748b;
            text-align: center;
            font-size: 0.9rem;
            padding: 0 20px;
        }

        /* --- A4 Paper Layout --- */
        .page-container {
            width: 210mm;
            height: 297mm;
            background: var(--paper-color);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* 3/4 Image Area */
        .image-zone {
            flex: 1; 
            width: 100%;
            position: relative;
            border-bottom: 2px solid #000;
            overflow: hidden; 
        }

        /* 1/4 Writing Area */
        .writing-zone {
            width: 100%;
            /* Padding handled by logic now to align borders */
            padding: 20px 20px 0 20px; 
            flex-shrink: 0; 
            transition: height 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        /* Real DOM elements for lines to ensure printing */
        .line-item {
            width: 100%;
            border-bottom: 1.5px solid var(--line-color);
            flex-shrink: 0;
            /* Height set by JS */
        }

        /* --- Draggable Image Element --- */
        .draggable-item {
            position: absolute;
            cursor: move;
            display: inline-block;
            min-width: 50px;
            min-height: 50px;
            touch-action: none;
        }

        .draggable-item.active {
            z-index: 100 !important;
        }

        .draggable-item:hover, .draggable-item.active {
            outline: 2px dashed var(--primary-color);
        }

        .draggable-item img {
            width: 100%;
            height: auto;
            display: block;
            pointer-events: none; 
        }

        .image-caption {
            font-size: 12px;
            text-align: center;
            margin-top: 4px;
            font-weight: 500;
            color: #000;
            word-break: break-all;
            background: rgba(255, 255, 255, 0.85);
            padding: 2px 4px;
            border-radius: 4px;
        }

        /* Resize Handle - Made larger for Mobile */
        .resize-handle {
            width: 30px;
            height: 30px;
            position: absolute;
            bottom: -5px;
            right: -5px;
            cursor: nwse-resize;
            display: none; 
            z-index: 20;
            touch-action: none; /* Critical for mobile */
        }
        
        /* Visual part of the handle */
        .resize-handle::after {
            content: '';
            position: absolute;
            bottom: 5px;
            right: 5px;
            width: 12px;
            height: 12px;
            background-color: var(--handle-color);
            border-radius: 50%;
            box-shadow: 0 0 2px white;
        }

        .draggable-item:hover .resize-handle, 
        .draggable-item.active .resize-handle {
            display: block;
        }

        /* Delete Button */
        .delete-btn {
            position: absolute;
            top: -12px;
            right: -12px;
            width: 28px;
            height: 28px;
            background: var(--danger-color);
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 26px;
            font-weight: bold;
            cursor: pointer;
            display: none;
            z-index: 21;
            font-size: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .draggable-item:hover .delete-btn,
        .draggable-item.active .delete-btn {
            display: block;
        }

        /* --- Print Styles --- */
        @media print {
            body {
                background: none;
                margin: 0;
                padding: 0;
                display: block;
                min-height: auto;
            }

            .controls, .instructions {
                display: none !important;
            }

            .page-container {
                box-shadow: none;
                margin: 0;
                width: 210mm; 
                height: 297mm;
                page-break-after: always;
                border: none;
            }

            .draggable-item {
                outline: none !important;
            }
            
            .resize-handle, .delete-btn {
                display: none !important;
            }
            
            /* Ensure borders print */
            .line-item {
                border-bottom-color: #000 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            @page {
                size: A4;
                margin: 0;
            }
        }

        /* --- Mobile Responsiveness --- */
        @media screen and (max-width: 850px) {
            .page-container {
                transform-origin: top center;
                transform: scale(0.45); 
                margin-bottom: -150mm; 
            }
            
            body {
                padding: 10px;
                padding-bottom: 100px; /* Space for controls */
                overflow-x: hidden;
            }

            .controls {
                width: 100%;
                bottom: 0;
                right: 0;
                padding: 10px;
                background: rgba(255, 255, 255, 0.95);
                border-top: 1px solid #ddd;
                justify-content: space-around;
            }
            
            .btn {
                padding: 8px 12px;
                font-size: 12px;
                flex: 1;
                justify-content: center;
            }
            
            .input-group {
                padding: 6px 12px;
                font-size: 12px;
            }
            
            /* Always show handles on mobile to avoid hover issues */
            .draggable-item .resize-handle {
                display: block;
                opacity: 0; /* Hidden but clickable until tapped */
            }
            .draggable-item.active .resize-handle {
                opacity: 1;
            }
            .draggable-item.active .delete-btn {
                display: block;
            }
        }
        
        @media screen and (min-width: 851px) and (max-width: 1024px) {
             .page-container {
                transform: scale(0.7);
                margin-bottom: -80mm;
             }
        }
    </style>
</head>
<body>

    <div class="instructions">
        Upload images. Drag to move. Use the bottom-right handle to resize.
    </div>

    <!-- The A4 Page -->
    <div class="page-container" id="page">
        <!-- Top 3/4: Image Drop Zone -->
        <div class="image-zone" id="imageZone">
            <!-- Images will be injected here -->
        </div>

        <!-- Bottom 1/4: Notes -->
        <div class="writing-zone">
            <!-- Lines generated as DIVs -->
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <div class="input-group">
            <label for="lineCount">Lines:</label>
            <input type="number" id="lineCount" value="8" min="0" max="25">
        </div>

        <input type="file" id="fileInput" accept="image/*,.tif,.tiff" multiple>
        
        <button class="btn" onclick="document.getElementById('fileInput').click()">
            <span>üì∑</span> Add
        </button>
        <button class="btn auto-btn" onclick="autoAlignImages()">
            <span>‚ú®</span> Auto Align
        </button>
        <button class="btn print-btn" onclick="window.print()">
            <span>üñ®Ô∏è</span> Print
        </button>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const imageZone = document.getElementById('imageZone');
        const writingZone = document.querySelector('.writing-zone');
        const lineCountInput = document.getElementById('lineCount');
        
        // --- Line Customization (Using DIVs for Print Safety) ---
        function updateLines() {
            const count = parseInt(lineCountInput.value) || 0;
            const LINE_HEIGHT_MM = 10; 
            const PADDING_TOP_PX = 20; 
            
            writingZone.innerHTML = ''; // Clear existing
            
            if (count > 0) {
                // Set container height
                writingZone.style.height = `calc(${count * LINE_HEIGHT_MM}mm + ${PADDING_TOP_PX}px)`;
                
                // Add top spacing
                const spacer = document.createElement('div');
                spacer.style.height = `${PADDING_TOP_PX}px`;
                spacer.style.width = '100%';
                writingZone.appendChild(spacer);

                // Create individual line elements
                for (let i = 0; i < count; i++) {
                    const line = document.createElement('div');
                    line.className = 'line-item';
                    line.style.height = `${LINE_HEIGHT_MM}mm`;
                    writingZone.appendChild(line);
                }
            } else {
                writingZone.style.height = `${PADDING_TOP_PX}px`;
            }
        }

        lineCountInput.addEventListener('input', updateLines);
        lineCountInput.addEventListener('change', updateLines);
        updateLines();

        // --- Auto Align Logic ---
        function autoAlignImages() {
            const items = Array.from(document.querySelectorAll('.draggable-item'));
            if (items.length === 0) return;

            const zoneW = imageZone.offsetWidth;
            const zoneH = imageZone.offsetHeight;
            const padding = 10; // Gap between images
            
            // Calculate grid dimensions
            // Try to keep it somewhat square, favoring width
            const cols = Math.ceil(Math.sqrt(items.length));
            const rows = Math.ceil(items.length / cols);
            
            const cellW = (zoneW - (padding * (cols + 1))) / cols;
            const cellH = (zoneH - (padding * (rows + 1))) / rows;
            
            items.forEach((item, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                
                const left = padding + col * (cellW + padding);
                const top = padding + row * (cellH + padding);
                
                // Animate position
                item.style.transition = 'all 0.3s ease';
                item.style.left = `${left}px`;
                item.style.top = `${top}px`;
                
                // Resize logic: Fit inside cell while maintaining aspect ratio
                const img = item.querySelector('img');
                
                // We default to filling width, but constrain by height if needed
                let newWidth = cellW;
                
                // If the image is loaded, we can check aspect ratio to prevent vertical overflow
                if (img.naturalWidth && img.naturalHeight) {
                    const aspect = img.naturalWidth / img.naturalHeight;
                    
                    // Reserve height for caption so it doesn't get cut off or overlap rows
                    // 35px is roughly enough for 2 lines of text + padding
                    const captionReserve = 35; 
                    const maxImgH = cellH - captionReserve;

                    const projectedImgH = newWidth / aspect;
                    
                    if (projectedImgH > maxImgH) {
                        // Too tall, constrain by height
                        newWidth = maxImgH * aspect;
                    }
                }
                
                item.style.width = `${newWidth}px`;
                
                // Remove transition after animation so dragging isn't laggy
                setTimeout(() => {
                    item.style.transition = '';
                }, 350);
            });
        }

        // --- File Handling ---
        fileInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            for (const file of files) {
                try {
                    const fileName = file.name.replace(/\.[^/.]+$/, ""); 
                    let imageUrl;

                    if (file.type === 'image/tiff' || file.name.toLowerCase().endsWith('.tif') || file.name.toLowerCase().endsWith('.tiff')) {
                        imageUrl = await processTiff(file);
                    } else {
                        imageUrl = URL.createObjectURL(file);
                    }
                    createImageElement(imageUrl, fileName);
                } catch (err) {
                    console.error(err);
                    alert(`Error loading ${file.name}`);
                }
            }
            fileInput.value = '';
        });

        // TIFF Support
        function processTiff(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const buffer = e.target.result;
                        const ifds = UTIF.decode(buffer);
                        if (!ifds || ifds.length === 0) throw new Error("Invalid TIFF");
                        UTIF.decodeImage(buffer, ifds[0]);
                        const rgba = UTIF.toRGBA8(ifds[0]);
                        const canvas = document.createElement("canvas");
                        canvas.width = ifds[0].width;
                        canvas.height = ifds[0].height;
                        const ctx = canvas.getContext("2d");
                        const imageData = ctx.createImageData(canvas.width, canvas.height);
                        for (let i = 0; i < rgba.length; i++) imageData.data[i] = rgba[i];
                        ctx.putImageData(imageData, 0, 0);
                        resolve(canvas.toDataURL("image/png"));
                    } catch (err) { reject(err); }
                };
                reader.readAsArrayBuffer(file);
            });
        }

        // --- Item Creation & Interaction ---
        function createImageElement(src, name) {
            const wrapper = document.createElement('div');
            wrapper.classList.add('draggable-item', 'active'); // Start active
            
            wrapper.style.left = '20px';
            wrapper.style.top = '20px';
            wrapper.style.width = '200px'; 

            wrapper.innerHTML = `
                <img src="${src}" draggable="false">
                <div class="image-caption">${name}</div>
                <div class="resize-handle"></div>
                <div class="delete-btn">√ó</div>
            `;

            // Delete logic
            wrapper.querySelector('.delete-btn').addEventListener('touchstart', (e) => {
                e.stopPropagation();
                wrapper.remove();
            });
            wrapper.querySelector('.delete-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                wrapper.remove();
            });

            imageZone.appendChild(wrapper);
            makeInteractive(wrapper);
            
            // Auto align if user wants, or just bring to front
            bringToFront(wrapper);
        }

        function makeInteractive(element) {
            const handle = element.querySelector('.resize-handle');
            let isDragging = false;
            let isResizing = false;
            let startX, startY, initialLeft, initialTop, initialWidth;

            // --- Selection Logic ---
            element.addEventListener('mousedown', () => activate(element));
            element.addEventListener('touchstart', () => activate(element));

            function activate(el) {
                document.querySelectorAll('.draggable-item').forEach(i => i.classList.remove('active'));
                el.classList.add('active');
                bringToFront(el);
            }

            // --- Mouse Events ---
            element.addEventListener('mousedown', (e) => {
                if(e.target === handle || e.target.classList.contains('delete-btn')) return;
                startDrag(e.clientX, e.clientY);
            });

            handle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                startResize(e.clientX, e.clientY);
            });

            // --- Touch Events ---
            element.addEventListener('touchstart', (e) => {
                if(e.target === handle || e.target.classList.contains('delete-btn')) return;
                startDrag(e.touches[0].clientX, e.touches[0].clientY);
                // Prevent scrolling while dragging image
                if(e.target.tagName !== 'INPUT') e.preventDefault(); 
            }, { passive: false });

            handle.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                startResize(e.touches[0].clientX, e.touches[0].clientY);
                e.preventDefault(); 
            }, { passive: false });


            function startDrag(x, y) {
                isDragging = true;
                startX = x;
                startY = y;
                initialLeft = element.offsetLeft;
                initialTop = element.offsetTop;
                
                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('mouseup', stopInteraction);
                document.addEventListener('touchmove', onTouchDragMove, { passive: false });
                document.addEventListener('touchend', stopInteraction);
            }

            function startResize(x, y) {
                isResizing = true;
                startX = x;
                initialWidth = element.offsetWidth;
                
                document.addEventListener('mousemove', onResizeMove);
                document.addEventListener('mouseup', stopInteraction);
                document.addEventListener('touchmove', onTouchResizeMove, { passive: false });
                document.addEventListener('touchend', stopInteraction);
            }

            function onDragMove(e) { move(e.clientX, e.clientY); }
            function onTouchDragMove(e) { 
                move(e.touches[0].clientX, e.touches[0].clientY); 
            }

            function move(x, y) {
                if (!isDragging) return;
                const dx = x - startX;
                const dy = y - startY;
                element.style.left = `${initialLeft + dx}px`;
                element.style.top = `${initialTop + dy}px`;
            }

            function onResizeMove(e) { resize(e.clientX); }
            function onTouchResizeMove(e) { resize(e.touches[0].clientX); }

            function resize(x) {
                if (!isResizing) return;
                const dx = x - startX;
                const newWidth = Math.max(50, initialWidth + dx);
                element.style.width = `${newWidth}px`;
            }

            function stopInteraction() {
                isDragging = false;
                isResizing = false;
                document.removeEventListener('mousemove', onDragMove);
                document.removeEventListener('mouseup', stopInteraction);
                document.removeEventListener('touchmove', onTouchDragMove);
                document.removeEventListener('touchend', stopInteraction);
                document.removeEventListener('mousemove', onResizeMove);
                document.removeEventListener('touchmove', onTouchResizeMove);
            }
        }

        function bringToFront(el) {
            const items = document.querySelectorAll('.draggable-item');
            let maxZ = 0;
            items.forEach(item => {
                const z = parseInt(window.getComputedStyle(item).zIndex) || 0;
                if (z > maxZ) maxZ = z;
            });
            el.style.zIndex = maxZ + 1;
        }
    </script>
</body>
</html>
